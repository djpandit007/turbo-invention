# Section 8: State Persistence

## 107: Volumes

Volume stores the data generated by a pod even after the pod is deleted.
The volume needs storage which can be configured in multiple ways.
We mount the volume once it is created to access it from a container.

## 108: Persistent Volumes

Access Mode defines how a Volume should be mounted on the hosts.
The supported values are `ReadOnlyMany`, `ReadWriteOnce` or `ReadWriteMany` mode.
Persistent Volumes can be configured to be recycled or retained after the associated
claim has been deleted.
If recycled, the data is scrubbed before assigning the volume to other claims.

## 109: Persistent Volume Claims

Once the Persistent Volume Claims are created, Kubernetes binds the Persistent Volumes
to Claims based on the request and properties set on the volume.
Every Persistent Volume Claim is bound to a single Persistent Volume. There is a
1:1 mapping between Persistent Volume and Persistent Volume Claim.

## 114: Storage Classes

Every time an application requires storage we have to manually provision the disk
and then manually create a persistent volume definition file using the same name
as that of the disk created. This is called Static Provisioning of Volumes.

We can define a provisioner that can automatically provision storage and attach
that to pods when a claim is made. That's called Dynamic Provisioning of Volumes.
Storage Classes allow us to dynamically provision volumes.

The Storage Class automatically creates a Persistent Storage so we don't have to.

## 116: Why Stateful Sets?

Stateful sets are similar to deployment sets. As is, they create pods based on
templates. They can scale up and scale down. They can perform rolling updates
and rollbacks.

There are differences though:

- With stateful sets, pods are created in a sequential
  order. After the first pod is deployed, it must be in a running and ready state
  before the next pod is deployed.
- Stateful sets assign a unique ordinal index to each pod starting from zero
  and incrementing by 1. Each pod gets a unique name derived from this index
  combined with the stateful set name. We can be sure that the first pod in
  any stateful set is always going to be name of the stateful set followed by zero.
  Stateful sets maintain a sticky identity for each of their pods.

Stateful sets should be used if our instances need to come up in a particular
order or if the instances need a stable name.

## 117: Stateful Sets Introduction

The template definition for stateful set is similar to a deployment.
Stateful sets require a headless service name to be specified.

## Noteworthy Commands

`kubectl get persistentvolume` will show all persistent volumes.

`kubectl exec <pod-name> -- cat <file-path>` will read the file located at
`file-path` within the pod `pod-name`.
